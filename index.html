<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Clock – Mobile-Safe, Jitter & Tick</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Clock">
  <meta name="format-detection" content="telephone=no">

  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100dvh;
      background: #fff;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    body { overflow: hidden; }
    #clockCanvas {
      display: block;
      width: 100vw;
      height: 100dvh;
      cursor: pointer;
    }
    .controls {
      position: fixed;
      left: 0; right: 0;
      bottom: env(safe-area-inset-bottom);
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding:
        0.5rem
        calc(env(safe-area-inset-right) + 8px)
        calc(env(safe-area-inset-bottom) + 8px)
        calc(env(safe-area-inset-left) + 8px);
      z-index: 10;
      background: rgba(255,255,255,0.65);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      transition: opacity 120ms ease;
    }
    .controls.hidden { opacity: 0; pointer-events: none; }
    .controls button {
      padding: 0.6em 1em;
      font-size: 1rem;
      background: #ccc;
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: filter 0.1s;
    }
    .controls button:active { filter: brightness(0.85); }
  </style>
</head>
<body>

  <canvas id="clockCanvas"></canvas>

  <div id="controls" class="controls">
    <button id="toggleBtn">Toggle</button>
    <button id="resetBtn">Reset</button>
    <button id="lightBtn">Light</button>
    <button id="jitterBtn">Jitter</button>
    <button id="soundBtn">Sound</button>
    <button id="hBtn">H</button>
  </div>

  <script>
    const canvas = document.getElementById('clockCanvas');
    const ctx = canvas.getContext('2d');
    const controlsEl = document.getElementById('controls');
    const toggleBtn = document.getElementById('toggleBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const lightBtn  = document.getElementById('lightBtn');
    const jitterBtn = document.getElementById('jitterBtn');
    const soundBtn  = document.getElementById('soundBtn');
    const hBtn      = document.getElementById('hBtn');

    let width, height, cx, cy, r;
    let lastRAFTime = performance.now() / 1000;

    // Theme
    let lightMode = true;
    const themes = {
      light: { bg: '#fff', mainTicks: ['#000','#555','#777'], text: '#000', hand: '#f00', pivot: '#000' },
      dark:  { bg: '#000', mainTicks: ['#fff','#555','#333'], text: '#fff', hand: '#f00', pivot: '#fff' }
    };

    // Modes
    let jitterMode = false;
    let controlsHidden = false;

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      const vp = window.visualViewport;
      const w = vp ? vp.width  : window.innerWidth;
      const h = vp ? vp.height : window.innerHeight;

      canvas.width  = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width  = w + 'px';
      canvas.style.height = h + 'px';

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      width = w; height = h;
      cx = width / 2; cy = height / 2;
      r  = Math.min(width, height) * 0.45;

      document.body.style.background = themes[lightMode ? 'light' : 'dark'].bg;
      controlsEl.style.background = lightMode
        ? 'rgba(255,255,255,0.65)'
        : 'rgba(0,0,0,0.35)';
    }
    window.addEventListener('resize', resize);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', resize);

    // Timer state
    let startTime = 0, pausedTime = 0, state = 'paused', resetStart = 0,
        resetStartElapsed = 0, mainAngleAtReset = 0, subAngleAtReset = 0,
        resetDuration = 0, flashStart = 0, flashDuration = 0.06;

    toggleBtn.onclick = () => {
      if (state === 'running') {
        pausedTime = performance.now() / 1000 - startTime; state = 'paused';
      } else {
        startTime = performance.now() / 1000 - pausedTime; state = 'running';
      }
    };

    resetBtn.onclick = () => {
      const now = performance.now() / 1000;
      resetStartElapsed = (state === 'running') ? now - startTime : pausedTime;
      flashStart = now;
      if (resetStartElapsed < 1e-6) return;
      mainAngleAtReset = (resetStartElapsed % 48) * (360/48);
      subAngleAtReset  = (resetStartElapsed % 1) * 360;
      resetDuration    = mainAngleAtReset / 360;
      resetStart       = now; state = 'resetting';

      initPhys(physMain, 360/48);
      initPhys(physSub,  360/10);
    };

    lightBtn.onclick = () => {
      lightMode = !lightMode;
      document.body.style.background = themes[lightMode ? 'light' : 'dark'].bg;
      controlsEl.style.background = lightMode
        ? 'rgba(255,255,255,0.65)'
        : 'rgba(0,0,0,0.35)';
    };

    jitterBtn.onclick = () => {
      jitterMode = !jitterMode;
      const now = performance.now()/1000;
      const elapsed = (state==='running') ? now - startTime : (state==='paused' ? pausedTime : 0);
      const mainSmooth = (elapsed%48)/48*360;
      const subSmooth  = (elapsed%1)*360;
      initPhys(physMain, 360/48, mainSmooth);
      initPhys(physSub,  360/10, subSmooth);
    };

    // Center tap: toggle controls
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hitR = r / 12; // radius ≈ r/6 diameter
      const inside = ((x - cx) ** 2 + (y - cy) ** 2) <= (hitR * hitR);
      if (inside) {
        controlsHidden = !controlsHidden;
        controlsEl.classList.toggle('hidden', controlsHidden);
      }
    }, { passive: true });

    // ---------- Natural Jitter Model ----------
    function makePhys(params) {
      return {
        dispDeg: 0, vel: 0,
        lastIndex: -1, turns: 0, targetDeg: 0,
        stepDeg: params.stepDeg,
        k: params.k, c: params.c, kick: params.kick,
        noiseTau: params.noiseTau, noiseAmp: params.noiseAmp, noise: 0
      };
    }
    function initPhys(phys, stepDeg, currentDeg = 0) {
      phys.stepDeg = stepDeg;
      phys.dispDeg = currentDeg;
      phys.vel = 0;
      phys.noise = 0;
      phys.turns = 0;
      phys.lastIndex = -1;
      phys.targetDeg = currentDeg;
    }
    const physMain = makePhys({ stepDeg: 360/48, k: 120, c: 18,  kick: 140, noiseTau: 0.7, noiseAmp: 0.6 });
    const physSub  = makePhys({ stepDeg: 360/10, k: 140, c: 20,  kick:  80, noiseTau: 0.5, noiseAmp: 0.45 });

    function stepPhys(phys, dt) {
      const decay = Math.exp(-dt / phys.noiseTau);
      const sigma = Math.sqrt(1 - decay * decay);
      phys.noise = phys.noise * decay + sigma * phys.noiseAmp * (Math.random()*2 - 1);
      const dx = phys.dispDeg - phys.targetDeg;
      const acc = -phys.k * dx - phys.c * phys.vel + phys.noise;
      phys.vel += acc * dt;
      phys.dispDeg += phys.vel * dt;
      phys.dispDeg += 0.02 * (Math.random()*2 - 1);
    }
    function mod360(d) { d %= 360; if (d < 0) d += 360; return d; }

    // ========= SOUND: looping 60s minute-track (plays in background) =========
    let audioCtx = null;
    let isSoundOn = false;
    let tickLoaded = false, tickLoading = false;
    let tickBufferA = null, tickBufferB = null;

    let bgAudio = null;
    let bgAudioURL = null;

    soundBtn.onclick = async () => {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch {} }

      if (!tickLoaded && !tickLoading) {
        tickLoading = true;
        try {
          const arrBuf = await fetch('hoangtick.mp3', { cache: 'reload' }).then(r => {
            if (!r.ok) throw new Error('hoangtick.mp3 not found next to HTML');
            return r.arrayBuffer();
          });
          const decoded = await audioCtx.decodeAudioData(arrBuf.slice(0));
          const { a, b } = extractTickPairs(decoded);
          tickBufferA = a; tickBufferB = b || a;

          await buildMinuteTrackAndSetupAudio();
          tickLoaded = true;
          soundBtn.textContent = 'Sound (Loaded)';
        } catch (e) {
          console.warn(e);
          const usingFile = location.protocol === 'file:';
          alert(usingFile
            ? 'Opened via file:// so fetch() is blocked.\nStart a local server or host online.'
            : 'Could not load hoangtick.mp3. Ensure it is next to the HTML.');
        } finally {
          tickLoading = false;
        }
      }

      isSoundOn = !isSoundOn;
      soundBtn.style.background = isSoundOn ? '#9fe29f' : '#ccc';
      if (bgAudio) {
        if (isSoundOn) {
          resyncAudioToClock();
          try { await bgAudio.play(); } catch {}
        } else {
          bgAudio.pause();
        }
      }
    };

    async function buildMinuteTrackAndSetupAudio() {
      const sr = 44100;
      const durationSec = 60;
      const off = new OfflineAudioContext(1, sr * durationSec, sr);

      for (let sec = 0; sec < durationSec; sec++) {
        const src = off.createBufferSource();
        src.buffer = (sec % 2 === 0) ? tickBufferA : tickBufferB;
        const gain = off.createGain();
        gain.gain.setValueAtTime(0.9, sec);
        src.connect(gain).connect(off.destination);
        src.start(sec);
      }

      const rendered = await off.startRendering();
      const wavBlob = audioBufferToWavBlob(rendered);
      if (bgAudioURL) URL.revokeObjectURL(bgAudioURL);
      bgAudioURL = URL.createObjectURL(wavBlob);

      if (!bgAudio) {
        bgAudio = new Audio();
        bgAudio.loop = true;
        bgAudio.preload = 'auto';
        bgAudio.playsInline = true;
        bgAudio.crossOrigin = 'anonymous';
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden && isSoundOn && bgAudio) resyncAudioToClock();
        });
      }
      bgAudio.src = bgAudioURL;
    }

    function resyncAudioToClock() {
      if (!bgAudio) return;
      const nowSec = performance.now() / 1000;
      let elapsed;
      if (state === 'running') elapsed = nowSec - startTime;
      else if (state === 'paused') elapsed = pausedTime;
      else {
        const d = nowSec - resetStart;
        elapsed = Math.max(0, resetStartElapsed * Math.max(0, 1 - d / Math.max(resetDuration, 0.0001)));
      }
      const target = ((elapsed % 60) + 60) % 60;
      const cur = bgAudio.currentTime % 60;
      if (Math.abs(cur - target) > 0.12) {
        try { bgAudio.currentTime = target; } catch {}
      }
    }

    function extractTickPairs(decoded) {
      const sr = decoded.sampleRate;
      const chs = decoded.numberOfChannels;
      const len = decoded.length;
      const analyzeFrames = Math.min(len, Math.floor(sr * 6));
      const mono = new Float32Array(analyzeFrames);
      for (let ch = 0; ch < chs; ch++) {
        const data = decoded.getChannelData(ch);
        for (let i = 0; i < analyzeFrames; i++) mono[i] += data[i] / chs;
      }
      let maxAbs = 1e-9;
      for (let i = 0; i < analyzeFrames; i++) maxAbs = Math.max(maxAbs, Math.abs(mono[i]));
      const thresh = maxAbs * 0.45, minSep = Math.floor(sr * 0.18);
      const peaks = [];
      let i = 1, last = -minSep;
      while (i < analyzeFrames - 1 && peaks.length < 8) {
        if (i - last < minSep) { i++; continue; }
        const v = Math.abs(mono[i]);
        if (v > thresh && v >= Math.abs(mono[i-1]) && v >= Math.abs(mono[i+1])) {
          peaks.push(i); last = i; i += minSep;
        } else i++;
      }
      if (peaks.length === 0) peaks.push(Math.floor(sr * 0.25));
      const pA = peaks[0], pB = peaks[1] ?? peaks[0];
      const pre = Math.floor(sr * 0.005), dur = Math.floor(sr * 0.055);
      function sliceAt(p) {
        const start = Math.max(0, p - pre);
        const lenS  = Math.min(dur, decoded.length - start);
        const out = audioCtx.createBuffer(1, lenS, sr);
        const outArr = out.getChannelData(0);
        for (let k = 0; k < lenS; k++) {
          const x = mono[start + k] || 0;
          const fi = Math.min(1, k / (sr * 0.002));
          const fo = Math.min(1, (lenS - 1 - k) / (sr * 0.004));
          outArr[k] = x * Math.min(fi, fo);
        }
        return out;
      }
      return { a: sliceAt(pA), b: sliceAt(pB) };
    }

    function audioBufferToWavBlob(abuf) {
      const data = abuf.getChannelData(0);
      const sampleRate = abuf.sampleRate;
      const numOfChan = 1;
      const len = data.length * 2 + 44;
      const buffer = new ArrayBuffer(len);
      const view = new DataView(buffer);

      writeStr(view, 0, 'RIFF');
      view.setUint32(4, len - 8, true);
      writeStr(view, 8, 'WAVE');
      writeStr(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numOfChan * 2, true);
      view.setUint16(32, numOfChan * 2, true);
      view.setUint16(34, 16, true);
      writeStr(view, 36, 'data');
      view.setUint32(40, len - 44, true);

      let offset = 44;
      for (let i = 0; i < data.length; i++, offset += 2) {
        const s = Math.max(-1, Math.min(1, data[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
      }
      return new Blob([view], { type: 'audio/wav' });

      function writeStr(dv, pos, str) {
        for (let i = 0; i < str.length; i++) dv.setUint8(pos + i, str.charCodeAt(i));
      }
    }

    // "H" — reset to zero & start (and re-sync audio to 0 if playing)
    function hardResetAndStart() {
      const nowSec = performance.now() / 1000;
      startTime = nowSec;
      pausedTime = 0;
      state = 'running';
      resetStart = 0; resetStartElapsed = 0; resetDuration = 0;
      initPhys(physMain, 360/48, 0);
      initPhys(physSub,  360/10,  0);
      if (bgAudio && isSoundOn) { try { bgAudio.currentTime = 0; } catch {} }
      flashStart = nowSec;
    }
    hBtn.onclick = hardResetAndStart;

    // ----------------- DRAW / ANIMATE -----------------
    function draw(elapsed, dt) {
      const t = themes[lightMode ? 'light' : 'dark'];
      ctx.clearRect(0, 0, width, height);

      // Ticks
      for (let i=0;i<192;i++){
        const ang=(i/192)*2*Math.PI-Math.PI/2;
        let len, col, lw;
        if(i%16===0){len=r*0.10*1.2; col=t.mainTicks[0]; lw=r*0.02;} 
        else if(i%4===0){len=r*0.06*1.2; col=t.mainTicks[1]; lw=r*0.015;} 
        else {len=r*0.03*1.2; col=t.mainTicks[2]; lw=r*0.016;}
        const x1=cx+Math.cos(ang)*(r-len), y1=cy+Math.sin(ang)*(r-len),
              x2=cx+Math.cos(ang)*r,       y2=cy+Math.sin(ang)*r;
        ctx.beginPath(); ctx.lineCap='butt'; ctx.strokeStyle=col; ctx.lineWidth=lw;
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }

      // Labels
      ctx.fillStyle=t.text; ctx.font='bold '+(r*0.16)+'px sans-serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(let j=0;j<12;j++){
        const ang=(j/12)*2*Math.PI-Math.PI/2, txt=(j===0?'48':(j*4).toString());
        ctx.fillText(txt, cx+Math.cos(ang)*r*0.75, cy+Math.sin(ang)*r*0.75);
      }

      // Digital
      const now=performance.now()/1000;
      ctx.fillStyle=(now-flashStart<flashDuration)?t.hand:t.text;
      ctx.font='bold '+(r*0.10)+'px sans-serif';
      const mins=String(Math.floor(elapsed/60)).padStart(2,'0'),
            secs=String(Math.floor(elapsed%60)).padStart(2,'0'),
            cs  =String(Math.floor((elapsed%1)*100)).padStart(2,'0');
      ctx.fillText(`${mins}:${secs}.${cs}`, cx, cy+r*0.4);

      // Base smooth angles
      const mainSmooth = (elapsed%48)/48*360;
      const subSmooth  = (elapsed%1)*360;

      // Indices for step targets
      const mainIdx = Math.floor(elapsed % 48);
      const subIdx  = Math.floor((elapsed % 1) * 10);

      if (state === 'running') {
        if (!jitterMode) {
          physMain.dispDeg = mainSmooth; physMain.vel = 0; physMain.lastIndex = mainIdx; physMain.turns = 0; physMain.targetDeg = mainSmooth;
          physSub.dispDeg  = subSmooth;  physSub.vel  = 0; physSub.lastIndex  = subIdx;  physSub.turns  = 0; physSub.targetDeg  = subSmooth;
        } else {
          if (physMain.lastIndex === -1) physMain.lastIndex = mainIdx;
          if (mainIdx < physMain.lastIndex) physMain.turns += 1;
          const newMainTarget = physMain.turns * 360 + mainIdx * physMain.stepDeg;
          const mainTickChanged = (mainIdx !== physMain.lastIndex);
          if (mainTickChanged) {
            const dir = Math.sign(newMainTarget - physMain.dispDeg) || 1;
            physMain.vel += physMain.kick * dir;
          }
          physMain.targetDeg = newMainTarget;
          stepPhys(physMain, dt);
          physMain.lastIndex = mainIdx;

          if (physSub.lastIndex === -1) physSub.lastIndex = subIdx;
          if (subIdx < physSub.lastIndex) physSub.turns += 1;
          const newSubTarget = physSub.turns * 360 + subIdx * physSub.stepDeg;
          const subTickChanged = (subIdx !== physSub.lastIndex);
          if (subTickChanged) {
            const dirS = Math.sign(newSubTarget - physSub.dispDeg) || 1;
            physSub.vel += physSub.kick * dirS;
          }
          physSub.targetDeg = newSubTarget;
          stepPhys(physSub, dt);
          physSub.lastIndex = subIdx;
        }
      } else if (state === 'paused') {
        physMain.dispDeg = mainSmooth; physMain.vel = 0; physMain.lastIndex = Math.floor(pausedTime%48); physMain.turns = 0; physMain.targetDeg = mainSmooth;
        physSub.dispDeg  = subSmooth;  physSub.vel  = 0; physSub.lastIndex  = Math.floor((pausedTime%1)*10); physSub.turns = 0; physSub.targetDeg = subSmooth;
      } else {
        const d=now-resetStart;
        const mainDeg=mainAngleAtReset - d*360;
        const subDeg =subAngleAtReset  - d*360;
        if(d>=resetDuration){state='paused'; pausedTime=0;}
        physMain.dispDeg = mainDeg; physMain.vel = 0; physMain.lastIndex = -1; physMain.turns = 0; physMain.targetDeg = mainDeg;
        physSub.dispDeg  = subDeg;  physSub.vel  = 0; physSub.lastIndex  = -1; physSub.turns  = 0; physSub.targetDeg = subDeg;
      }

      // Sub-dial rim
      const sr=r*0.15, sx=cx+r*0.5-sr, sy=cy-r*0.3;
      ctx.beginPath(); ctx.strokeStyle=t.text; ctx.lineWidth=sr*0.02;
      ctx.arc(sx,sy,sr,0,2*Math.PI); ctx.stroke();

      // Sub ticks & nums
      ctx.fillStyle=t.text; ctx.font='bold '+(r*0.08*0.8)+'px sans-serif';
      for(let k=0;k<10;k++){
        const a=(k/10)*2*Math.PI-Math.PI/2;
        const x1=sx+Math.cos(a)*sr*0.9, y1=sy+Math.sin(a)*sr*0.9,
              x2=sx+Math.cos(a)*sr,     y2=sy+Math.sin(a)*sr;
        ctx.beginPath(); ctx.lineCap='butt'; ctx.strokeStyle=t.text; ctx.lineWidth=r*0.01;
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        ctx.fillText(k.toString(), sx+Math.cos(a)*sr*0.7, sy+Math.sin(a)*sr*0.7);
      }

      // Sub hand
      const subDrawDeg = mod360(physSub.dispDeg);
      const subRad=subDrawDeg*Math.PI/180-Math.PI/2;
      ctx.beginPath(); ctx.strokeStyle=t.hand; ctx.lineWidth=r*0.015; ctx.lineCap='round';
      ctx.moveTo(sx-Math.cos(subRad)*sr*0.3, sy-Math.sin(subRad)*sr*0.3);
      ctx.lineTo(sx+Math.cos(subRad)*sr*0.9, sy+Math.sin(subRad)*sr*0.9);
      ctx.stroke();

      // Sub center
      ctx.beginPath(); ctx.fillStyle=t.pivot; ctx.arc(sx,sy,r*0.015,0,2*Math.PI); ctx.fill();

      // Main hand
      const mainDrawDeg = mod360(physMain.dispDeg);
      const mRad=mainDrawDeg*Math.PI/180-Math.PI/2;
      ctx.beginPath(); ctx.strokeStyle=t.hand; ctx.lineWidth=r*0.02; ctx.lineCap='butt';
      ctx.moveTo(cx-Math.cos(mRad)*r*0.15, cy-Math.sin(mRad)*r*0.15);
      ctx.lineTo(cx+Math.cos(mRad)*r, cy+Math.sin(mRad)*r);
      ctx.stroke();

      // Pivot
      ctx.beginPath(); ctx.arc(cx,cy,r*0.04,0,2*Math.PI);
      ctx.strokeStyle=t.pivot; ctx.lineWidth=r*0.01; ctx.stroke();
      ctx.beginPath(); ctx.arc(cx,cy,r*0.018,0,2*Math.PI);
      ctx.fillStyle=t.pivot; ctx.fill();
    }

    function animate() {
      const now = performance.now()/1000;
      let elapsed;
      if(state==='running') elapsed = now - startTime;
      else if(state==='paused') elapsed = pausedTime;
      else { const d=now-resetStart; elapsed= Math.max(0, resetStartElapsed*(1-d/resetDuration)); }

      let dt = now - lastRAFTime; if (dt > 0.1) dt = 0.1;
      lastRAFTime = now;

      draw(elapsed, dt);
      requestAnimationFrame(animate);
    }

    resize();
    animate();
  </script>
</body>
</html>
